    <SUBSECTION>
      <NAME>
  Compiling Expressions
      </NAME>

      <TEXT>
  In this section and the next we implement the code generators to which the <SCHEMEINLINE>compile</SCHEMEINLINE>
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  dispatches.
      </TEXT>

      <SUBHEADING>
  <NAME>Compiling linkage code</NAME>
      </SUBHEADING>

      <TEXT>
  <INDEX>compiler for Scheme<SUBINDEX>linkage code</SUBINDEX></INDEX>
  In general, the output of each code generator will end with
  instructions<EMDASH/>generated by the
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SPLITINLINE><SCHEME><SCHEMEINLINE>compile-linkage</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>compile_linkage</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE><EMDASH/>that
  implement the required linkage.  If the linkage is <SCHEMEINLINE>return</SCHEMEINLINE> then
  we must generate the instruction <SPLITINLINE><SCHEME><SCHEMEINLINE>(goto (reg continue))</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>go_to(reg("continue"))</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.  This
  needs the <SCHEMEINLINE>continue</SCHEMEINLINE> register and does not modify any registers.
  If the linkage is <SCHEMEINLINE>next</SCHEMEINLINE>, then we needn<APOS/>t include any additional
  instructions.  Otherwise, the linkage is a label, and we generate a
  <SPLITINLINE><SCHEME><SCHEMEINLINE>goto</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>go_to</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> to that label, an instruction that does not need or modify
  any registers.<FOOTNOTE>This
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    uses a feature of <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> called <EM>
      <INDEX>list(s)<SUBINDEX>backquote with</SUBINDEX></INDEX>
      <INDEX>backquote</INDEX><INDEX>quasiquote</INDEX>
      <!-- \indcodeplus{`}{(backquote)}-->
      <!-- \indcodeplus{,}{(comma, used with backquote)}-->
      <INDEX>comma, used with backquote</INDEX>
      backquote</EM> (or <EM>quasiquote</EM>) that is handy for constructing lists.
    Preceding a list with a backquote symbol is much like quoting it,
    except that anything in the list that is flagged with a comma is evaluated.
  </FOOTNOTE>
      </TEXT>

      <TEXT>
  For example, if the value of <SCHEMEINLINE>linkage</SCHEMEINLINE> is the <SPLIT><SCHEME>symbol</SCHEME><JAVASCRIPT>string</JAVASCRIPT></SPLIT>
  <SPLITINLINE><SCHEME><SCHEMEINLINE>branch25</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>"branch25"</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, then the expression
  <SPLITINLINE><SCHEME><SCHEMEINLINE>`((goto (label ,linkage)))</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>go_to(label(linkage))</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
  evaluates to the list
  <SPLITINLINE><SCHEME><SCHEMEINLINE>((goto (label branch25)))</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>go_to(label("branch25"))</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.
  Similarly, if the value of <SPLITINLINE><SCHEME><SCHEMEINLINE>x</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>x</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> is the list <SPLITINLINE><SCHEME><SCHEMEINLINE>(a b c)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>list("a", "b", "c")</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, then
  <SPLITINLINE><SCHEME><SCHEMEINLINE>`(1 2 ,x)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>list(1, 2, head(x))</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
  evaluates to the list
  <SPLITINLINE><SCHEME><SCHEMEINLINE>(1 2 a)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>list(1, 2, "a")</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.

  <SNIPPET EVAL="no">
    <!--  \indcode*{compile-linkage} -->
    <SCHEME>
      (define (compile-linkage linkage)
      (cond ((eq? linkage 'return)
            (make-instruction-sequence '(continue) '()
            '((goto (reg continue)))))
            ((eq? linkage 'next)
            (empty-instruction-sequence))
            (else
            (make-instruction-sequence '() '()
            ` ((goto (label ,linkage)))))))
    </SCHEME>
    <JAVASCRIPT>
function compile_linkage(linkage) {
    return linkage === "return"
        ? make_instruction_sequence(list("continue"), list(), list(go_to(reg("continue"))))
        : linkage === "next"
        ? empty_instruction_sequence()
        : make_instruction_sequence(list(), list(), list(go_to(label(linkage))));
}
    </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

      <TEXT>
  The linkage code is appended to an instruction sequence by <SCHEMEINLINE>preserving</SCHEMEINLINE>
  the <SCHEMEINLINE>continue</SCHEMEINLINE> register, since a <SCHEMEINLINE>return</SCHEMEINLINE> linkage will
  require the <SCHEMEINLINE>continue</SCHEMEINLINE> register:
  If the given instruction sequence modifies <SCHEMEINLINE>continue</SCHEMEINLINE> and the
  linkage code needs it, <SCHEMEINLINE>continue</SCHEMEINLINE> will be saved and restored.

  <SNIPPET EVAL="no">
    <!--  \indcode*{end-with-linkage} -->
    <SCHEME>
      (define (end-with-linkage linkage instruction-sequence)
      (preserving '(continue)
      instruction-sequence
      (compile-linkage linkage)))
    </SCHEME>
    <JAVASCRIPT>
function end_with_linkage(linkage, instruction_sequence) {
    return preserving(list("continue"), instruction_sequence, compile_linkage(linkage));
}
    </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

      <SUBHEADING>
  <NAME>Compiling simple expressions</NAME>
      </SUBHEADING>

      <TEXT>
  <INDEX>compiler for Scheme<SUBINDEX>self-evaluating expressions</SUBINDEX></INDEX>
  <INDEX>compiler for Scheme<SUBINDEX>quotations</SUBINDEX></INDEX>
  <INDEX>compiler for Scheme<SUBINDEX>variables</SUBINDEX></INDEX>
  The code generators for self-evaluating expressions,
  quotations, and variables construct instruction
  sequences that assign the required value to the target register
  and then proceed as specified by the linkage descriptor.

  <SNIPPET EVAL="no">
    <SCHEME>
      <!--  \indcode*{compile-self-evaluating} -->
      (define (compile-self-evaluating exp target linkage)
      (end-with-linkage linkage
      (make-instruction-sequence '() (list target)
      `((assign ,target (const ,exp))))))

      <!--  \indcode*{compile-quoted} -->
      (define (compile-quoted exp target linkage)
      (end-with-linkage linkage
      (make-instruction-sequence '() (list target)
      `((assign ,target (const ,(text-of-quotation exp)))))))

      <!--  \indcode*{compile-variable} -->
      (define (compile-variable exp target linkage)
      (end-with-linkage linkage
      (make-instruction-sequence '(env) (list target)
      `((assign ,target
            (op lookup-variable-value)
            (const ,exp)
            (reg env))))))
    </SCHEME>
    <JAVASCRIPT>
<!--  \indcode*{compile-self-evaluating} -->
    function compile_self_evaluating(exp, target, linkage) {
        return end_with_linkage(
            linkage,
            make_instruction_sequence(
                list(),
                list(target),
                list(assign(target, constant(exp)))));
    }

<!--  \indcode*{compile-quoted} -->
    function compile_quoted(exp, target, linkage) {
        return end_with_linkage(
            linkage,
            make_instruction_sequence(
                list(),
                list(target),
                list(assign(target, constant(stringify(exp))))));
    }

<!--  \indcode*{compile-variable} -->
    function compile_variable(exp, target, linkage) {
        return end_with_linkage(
            linkage,
            make_instruction_sequence(
                list("env"),
                list(target),
                list(assign(target, op("lookup_variable_value"), constant(exp), reg("env")))));
    }
    </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

      <TEXT>
  All these assignment instructions modify the target register,
  and the one that looks up a variable needs the <SCHEMEINLINE>env</SCHEMEINLINE> register.
      </TEXT>

      <TEXT>
  <INDEX>compiler for Scheme<SUBINDEX>assignments</SUBINDEX></INDEX>
  <INDEX>compiler for Scheme<SUBINDEX>definitions</SUBINDEX></INDEX>
  Assignments and definitions are handled much as they are in the
  interpreter.  We recursively generate code that computes the value to
  be assigned to the variable, and append to it a two-instruction
  sequence that actually sets or defines the variable and assigns the
  value of the whole expression (the symbol <SCHEMEINLINE>ok</SCHEMEINLINE>) to the target
  register.  The recursive compilation has target <SCHEMEINLINE>val</SCHEMEINLINE> and linkage
  <SCHEMEINLINE>next</SCHEMEINLINE> so that the code will put its result into <SCHEMEINLINE>val</SCHEMEINLINE> and
  continue with the code that is appended after it.  The appending is
  done preserving <SCHEMEINLINE>env</SCHEMEINLINE>, since the environment is needed for setting
  or defining the variable and the code for the variable value could be
  the compilation of a complex expression that might modify the
  registers in arbitrary ways.

  <SNIPPET EVAL="no">
    <SCHEME>
      <!--  \indcode*{compile-assignment} -->
      (define (compile-assignment exp target linkage)
      (let ((var (assignment-variable exp))
            (get-value-code
            (compile (assignment-value exp) 'val 'next)))
      (end-with-linkage linkage
      (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
      `((perform (op set-variable-value!)
            (const ,var)
            (reg val)
            (reg env))
            (assign ,target (const ok))))))))

      <!--  \indcode*{compile-definition} -->
      (define (compile-definition exp target linkage)
      (let ((var (definition-variable exp))
            (get-value-code
            (compile (definition-value exp) 'val 'next)))
      (end-with-linkage linkage
      (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
      `((perform (op define-variable!)
            (const ,var)
            (reg val)
            (reg env))
            (assign ,target (const ok))))))))
    </SCHEME>
    <JAVASCRIPT>
function compile_assignment(exp, target, linkage) {
    const variable = assignment_variable(exp);
    const get_value_code = compile(assignment_value(exp), "val", "next");

    return end_with_linkage(
        linkage,
        preserving(
            "env",
            get_value_code,
            make_instruction_sequence(
                list("env", "val"),
                list(target),
                list(
                    perform(
                        op("set_variable_value"),
                        constant(variable),
                        reg("val"),
                        reg("env")),
                    assign(target, constant(ok)))))); /// FIXME: ok??=
}

function compile_definition(exp, target, linkage) {
    const variable = definition_variable(exp);
    const get_value_code = compile(definition_value(exp), "val", "next");

    return end_with_linkage(
        linkage,
        preserving(
            "env",
            get_value_code,
            make_instruction_sequence()
                list("env", "val"),
                list(target),
                list(
                    perform(
                        op("define_variable"),
                        constant(variable),
                        reg("val"),
                        reg("env")),
                    assign(target, constant(ok)))))); /// FIXME: ok??=
}
    </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

      <TEXT>
  The appended two-instruction sequence requires <SCHEMEINLINE>env</SCHEMEINLINE> and <SCHEMEINLINE>val</SCHEMEINLINE>
  and modifies the target.  Note that although we preserve <SCHEMEINLINE>env</SCHEMEINLINE> for
  this sequence, we do not preserve <SCHEMEINLINE>val</SCHEMEINLINE>, because the <SPLITINLINE><SCHEME><SCHEMEINLINE>get-value-code</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>get_value_code</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> is designed to explicitly place its result in <SCHEMEINLINE>val</SCHEMEINLINE> for use by this sequence.
  (In fact, if we did preserve <SCHEMEINLINE>val</SCHEMEINLINE>, we would
  have a bug, because this would cause the previous contents of <SCHEMEINLINE>val</SCHEMEINLINE> to be restored right after the <SPLITINLINE><SCHEME><SCHEMEINLINE>get-value-code</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>get_value_code</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> is run.)
      </TEXT>

      <SUBHEADING>
  <NAME>Compiling conditional expressions</NAME>
      </SUBHEADING>

      <TEXT>
  <INDEX>compiler for Scheme<SUBINDEX>conditionals</SUBINDEX></INDEX>
  The code for an <SCHEMEINLINE>if</SCHEMEINLINE> expression
  compiled with a given target and linkage has the form

  <SNIPPET EVAL="no" LATEX="yes">
    <SCHEME>
      ^compilation of predicate, target^ val^, linkage^ next
      (test (op false?) (reg val))
      (branch (label false-branch))
      true-branch
      ^compilation of consequent with given target and given linkage or^ after-if
      false-branch
      ^compilation of alternative with given target and linkage^
      after-if
    </SCHEME>
    <JAVASCRIPT>
      $\langle \textit{compilation of predicate, target}$ val$\textit{, linkage}$ next $\rangle$
      test(op("is_false"), reg("val")),
          branch(label("false_branch")),
      "true_branch",
      $\langle \textit{compilation of consequent with given target and given linkage or}$ after_if $\rangle$
      "false_branch",
      $\langle \textit{compilation of alternative with given target and linkage} \rangle$
      "after_if",
    </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

      <TEXT>
  To generate this code, we compile the predicate, consequent,
  and alternative, and combine the resulting code with instructions
  to test the predicate result and with newly generated labels to mark the true and false branches and the end of the 
  conditional.<FOOTNOTE>We can<APOS/>t just
    use the labels <SPLITINLINE><SCHEME><SCHEMEINLINE>true-branch</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>true_branch</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, <SPLITINLINE><SCHEME><SCHEMEINLINE>false-branch</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>false_branch</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, and
    <SPLITINLINE><SCHEME><SCHEMEINLINE>after-if</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>after_if</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> as shown above,
    because there might be more than one <SCHEMEINLINE>if</SCHEMEINLINE> in the program.
    <INDEX>compiler for Scheme<SUBINDEX>label generation</SUBINDEX></INDEX>
    The compiler uses the
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    <SPLITINLINE><SCHEME><SCHEMEINLINE>make-label</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>make_label</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> to generate labels.
    <SPLITINLINE><SCHEME><SCHEMEINLINE>Make-label</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>Make_label</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> takes a symbol as argument and returns a new symbol
    that begins with the given symbol.  For example, successive calls to
    <SPLITINLINE><SCHEME><SCHEMEINLINE>(make-label 'a)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>make_label("a")</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> would return <SCHEMEINLINE>a1</SCHEMEINLINE>, <SCHEMEINLINE>a2</SCHEMEINLINE>, and so on.
    <SPLITINLINE><SCHEME><SCHEMEINLINE>Make-label</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>Make_label</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> can be implemented similarly to the generation of
    unique variable names in the query language, as follows:
    <SNIPPET EVAL="no">
      <SCHEME>
        (define label-counter 0)

        (define (new-label-number)
        (set! label-counter (+ 1 label-counter))
        label-counter)

        <INDEX>character strings<SUBINDEX>primitive procedures for</SUBINDEX></INDEX>
        <!--  \indcode*{make-label} -->
        (define (make-label name)
        (string-&gt;symbol
        (string-append (symbol-&gt;string name)
              (number-&gt;string (new-label-number)))))
      </SCHEME>
      <JAVASCRIPT>
        let label_counter = 0;

        function new_label_number() {
            label_counter = label_counter + 1;
            return label-counter;
        }

        <INDEX>character strings<SUBINDEX>primitive functions for</SUBINDEX></INDEX>
        <!--  \indcode*{make-label} -->
        function make_label(name) {
            return name + stringify(new_label_number());
        }
      </JAVASCRIPT>
    </SNIPPET>
  </FOOTNOTE>
  In this arrangement of code, we must branch around the true branch
  if the test is false.  The only slight complication is in how the
  linkage for the true branch should be handled.  If the linkage for the
  conditional is <SCHEMEINLINE>return</SCHEMEINLINE> or a label, then the true and false
  branches will both use this same linkage.  If the linkage is <SCHEMEINLINE>next</SCHEMEINLINE>, the true branch ends with a jump around the code for the false
  branch to the label at the end of the conditional.

  <SNIPPET EVAL="no">
    <!--  \indcode*{compile-if} -->
    <SCHEME>
      (define (compile-if exp target linkage)
      (let ((t-branch (make-label 'true-branch))
            (f-branch (make-label 'false-branch))                    
            (after-if (make-label 'after-if)))
      (let ((consequent-linkage
            (if (eq? linkage 'next) after-if linkage)))
      (let ((p-code (compile (if-predicate exp) 'val 'next))
            (c-code
            (compile
            (if-consequent exp) target consequent-linkage))
            (a-code
            (compile (if-alternative exp) target linkage)))
            (preserving '(env continue)
            p-code
            (append-instruction-sequences
            (make-instruction-sequence '(val) '()
            `((test (op false?) (reg val))
            (branch (label ,f-branch))))
            (parallel-instruction-sequences
            (append-instruction-sequences t-branch c-code)
            (append-instruction-sequences f-branch a-code))
            after-if))))))
    </SCHEME>
    <JAVASCRIPT>
function compile_if(exp, target, linkage) {
    let t_branch = make_label("true_branch");
    let f_branch = make_label("false_branch");
    let after_if = make_label("after_if");
    let consequent_linkage = linkage === "next" ? after_if : linkage;
    let p_code = compile(if_predicate(exp), "val", "next");
    let c_code = compile(if_consequent(exp), target, consequent_linkage);
    let a_code = compile(if_alternative(exp), target, linkage);

    return preserving(list("env", "continue"),
                      p_code,
                      append_instruction_sequences(
                          make_instruction_sequence(list("val"),
                                                    list(),
                                                    list(
                                                        test(op("is_false"), reg("val")),
                                                        branch(label(f_branch)))),
                          parallel_instruction_sequences(
                              append_instruction_sequences(t_branch, c_code),
                              append_instruction_sequences(f_branch, a_code)),
                          after_if));
}
    </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

      <TEXT>
  <SCHEMEINLINE>Env</SCHEMEINLINE> is preserved around the predicate code because it could be needed by
  the true and false branches, and <SCHEMEINLINE>continue</SCHEMEINLINE> is preserved because it could
  be needed by the linkage code in those branches.  The code for the true and
  false branches (which are not executed sequentially) is appended using a
  special combiner <SPLITINLINE><SCHEME><SCHEMEINLINE>parallel-instruction-sequences</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>parallel_instruction_sequences</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> described in
  section<SPACE/><REF NAME="sec:combining-instruction-sequences"/>.
      </TEXT>

      <TEXT>
        <SPLIT><SCHEME></SCHEME><JAVASCRIPT>FIXME:</JAVASCRIPT></SPLIT>
  Note that <SCHEMEINLINE>cond</SCHEMEINLINE> is a derived expression, so all that the
  compiler needs to do handle it is to apply the <SCHEMEINLINE>cond-&gt;if</SCHEMEINLINE>
  transformer (from section<SPACE/><REF NAME="sec:representing-expressions"/>) and
  compile the resulting <SCHEMEINLINE>if</SCHEMEINLINE> expression.
      </TEXT>

      <SUBHEADING>
  <NAME>Compiling sequences</NAME>
      </SUBHEADING>

      <TEXT>
  <INDEX>compiler for Scheme<SUBINDEX>sequences of expressions</SUBINDEX></INDEX>
  The compilation of sequences (from
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  bodies or explicit <SCHEMEINLINE>begin</SCHEMEINLINE> expressions) parallels their evaluation.  Each expression of the
  sequence is compiled<EMDASH/>the last expression with the linkage specified
  for the sequence, and the other expressions with linkage <SCHEMEINLINE>next</SCHEMEINLINE>
  (to execute the rest of the sequence).
  The instruction sequences for the individual expressions are appended
  to form a single instruction sequence, such that <SCHEMEINLINE>env</SCHEMEINLINE> (needed for
  the rest of the sequence) and <SCHEMEINLINE>continue</SCHEMEINLINE> (possibly needed for the
  linkage at the end of the sequence) are preserved.

  <SNIPPET EVAL="no">
    <!--  \indcode*{compile-sequence} -->
    <SCHEME>
      (define (compile-sequence seq target linkage)
      (if (last-exp? seq)
      (compile (first-exp seq) target linkage)
      (preserving '(env continue)
      (compile (first-exp seq) target 'next)
      (compile-sequence (rest-exps seq) target linkage))))
    </SCHEME>
    <JAVASCRIPT>
function compile_sequence(seq, target, linkage) {
    return is_last_exp(seq)
        ? compile(first_exp(seq), target, linkage)
        : preserving(
            list("env", "continue"),
            compile(first_exp("seq"), target, "next"),
            compile_sequence(rest_exps(seq), target, linkage));
}
    </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

      <SUBHEADING>
  <NAME>Compiling <SCHEMEINLINE>lambda</SCHEMEINLINE> expressions</NAME>
      </SUBHEADING>

      <TEXT>
  <INDEX>compiler for Scheme<SUBINDEX>lambda@<SCHEMEINLINE>lambda</SCHEMEINLINE> expressions</SUBINDEX></INDEX>
  <SPLITINLINE><SCHEME>Lambda</SCHEME><JAVASCRIPT>Function definition expressions</JAVASCRIPT></SPLITINLINE> expressions construct
  <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>.
  The object code for a <SPLITINLINE><SCHEME>lambda</SCHEME><JAVASCRIPT>function definition</JAVASCRIPT></SPLITINLINE> expression must have the form

  <SNIPPET EVAL="no" LATEX="yes">
    <SCHEME>
      ^construct procedure object and assign it to target register^
      ^linkage^
    </SCHEME>
    <JAVASCRIPT>
$\langle \textit{construct procedure object and assign it to target register} \rangle$
$\langle \textit{linkage} \rangle$
    </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

      <TEXT>
  When we compile the <SPLITINLINE><SCHEME>lambda</SCHEME><JAVASCRIPT>function definition</JAVASCRIPT></SPLITINLINE> expression, we also generate the code for the
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  body.  Although the body won<APOS/>t be executed at the time of
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  construction, it is convenient to insert it into the object code right after
  the code for the <SPLITINLINE><SCHEME>lambda</SCHEME><JAVASCRIPT>function definition</JAVASCRIPT></SPLITINLINE>.  If the linkage for the <SPLITINLINE><SCHEME>lambda</SCHEME><JAVASCRIPT>function definition</JAVASCRIPT></SPLITINLINE> expression
  is a label or <SCHEMEINLINE>return</SCHEMEINLINE>, this is fine.  But if the linkage is <SCHEMEINLINE>next</SCHEMEINLINE>,
  we will need to skip around the code for the
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  body by using a linkage
  that jumps to a label that is inserted after the body.  The object code thus
  has the form

  <SNIPPET EVAL="no" LATEX="yes">
    <SCHEME>
      ^construct procedure object and assign it to target register^
      ^code for given linkage <EM>or</EM>^ (goto (label after-lambda))
      ^compilation of procedure body^
      after-lambda
    </SCHEME>
    <JAVASCRIPT>
$\langle \textit{construct procedure object and assign it to target register}\rangle$
$\langle \textit{code for given linkage}\rangle\ \textit{or}$ go_to(label("after_lambda"))
$\langle \textit{compilation of procedure body} \rangle$
"after_lambda",
    </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

      <TEXT>
  <SPLITINLINE><SCHEME><SCHEMEINLINE>Compile-lambda</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>Compile_function_expression</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> generates the code for constructing the
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  object followed by the code for the
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  body.
  The
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  object will be constructed at run time by combining
  the current environment (the environment at the point of definition)
  with the entry point to the compiled
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  body (a newly generated
  label).<FOOTNOTE>We need machine operations to implement a data
    structure for representing compiled
    <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>, analogous to the structure for
    compound
    <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    described in section<SPACE/><REF NAME="sec:eval-data-structures"/>:
    <SNIPPET EVAL="no">
      <SCHEME>
        <!--  \indcode*{make-compiled-procedure} -->
        (define (make-compiled-procedure entry env)
        (list 'compiled-procedure entry env))

        <!--  \indcode*{compiled-procedure?} -->
        (define (compiled-procedure? proc)
        (tagged-list? proc 'compiled-procedure))

        <!--  \indcode*{compiled-procedure-entry} -->
        (define (compiled-procedure-entry c-proc) (cadr c-proc))

        <!--  \indcode*{compiled-procedure-env} -->
        (define (compiled-procedure-env c-proc) (caddr c-proc))
      </SCHEME>
      <JAVASCRIPT>
        <!--  \indcode*{make-compiled-procedure} -->
        function make_compiled_procedure(entry, env) {
            return list("compiled_procedure", entry, env);
        }

        <!--  \indcode*{compiled-procedure?} -->
        function is_compiled_procedure(proc) {
            return is_tagged_list(proc, "compiled_procedure");
        } 

        <!--  \indcode*{compiled-procedure-entry} -->
        function compiled_procedure_entry(c_proc) {
            return head(tail(c_proc));
        }

        <!--  \indcode*{compiled-procedure-env} -->
        function compiled_procedure_env(c_proc) {
            return head(tail(tail(c_proc)));
        }
      </JAVASCRIPT>
    </SNIPPET>
    <LABEL NAME="foot:compiler-ops"/></FOOTNOTE>

  <SNIPPET EVAL="no">
    <SCHEME>
      <!--  \indcode*{compile-lambda} -->
      (define (compile-lambda exp target linkage)
      (let ((proc-entry (make-label 'entry))
            (after-lambda (make-label 'after-lambda)))
      (let ((lambda-linkage
            (if (eq? linkage 'next) after-lambda linkage)))
      (append-instruction-sequences
      (tack-on-instruction-sequence
            (end-with-linkage lambda-linkage
            (make-instruction-sequence '(env) (list target)
            `((assign ,target
            (op make-compiled-procedure)
            (label ,proc-entry)
            (reg env)))))
            (compile-lambda-body exp proc-entry))
      after-lambda))))
    </SCHEME>
    <JAVASCRIPT>
      <!--  \indcode*{compile-lambda} -->
function compile_function_expression(exp, target, linkage) {
    let proc_entry = make_label("entry");
    let after_fexp = make_label("after_lambda"); /// FIXME: lambda
    let lambda_linkage = linkage === "next" ? after_lambda : linkage;

    return append_instruction_sequences(
        tack_on_instruction_sequence(
            end_with_linkage(
                lambda_linkage,
                make_instruction_sequence(
                    list("env"), 
                    list(target),
                    list(assign(target, op("make_compiled_procedure"), label(proc_entry), reg("env")))), 
            compile_function_expression_body(exp, proc_entry)),
            after_lambda));
}
    </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

      <TEXT>
  <SPLITINLINE><SCHEME><SCHEMEINLINE>Compile-lambda</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>Compile_function_expression</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> uses the special combiner <SPLITINLINE><SCHEME><SCHEMEINLINE>tack-on-instruction\?sequence</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>tack_on_instruction_sequence</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
  (section<SPACE/><REF NAME="sec:combining-instruction-sequences"/>) rather than <SPLITINLINE><SCHEME><SCHEMEINLINE>append-instruction-sequences</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>append_instruction_sequences</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> to append the
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  body to the <SCHEMEINLINE>lambda</SCHEMEINLINE>
  expression code, because the body is not part of the sequence of instructions
  that will be executed when the combined sequence is entered; rather, it is in
  the sequence only because that was a convenient place to put it.
      </TEXT>

      <TEXT>
  <SPLITINLINE><SCHEME><SCHEMEINLINE>Compile-lambda-body</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>Compile_lambda_body</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> constructs the code for the body of the
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>.  This code begins with a label for the entry point.  Next
  come instructions that will cause the run-time evaluation environment
  to switch to the correct environment for evaluating the
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  body<EMDASH/>namely, the definition environment of the
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, extended
  to include the bindings of the formal parameters to the arguments with
  which the
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  is called.  After this comes the code for the
  sequence of expressions that makes up the
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  body.
  The sequence is compiled with linkage <SCHEMEINLINE>return</SCHEMEINLINE> and target <SCHEMEINLINE>val</SCHEMEINLINE>
  so that it will end by returning from the
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  with the
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  result in <SCHEMEINLINE>val</SCHEMEINLINE>.

  <SNIPPET EVAL="no">
    <SCHEME>
      (define (compile-lambda-body exp proc-entry)
      (let ((formals (lambda-parameters exp)))
      (append-instruction-sequences
      (make-instruction-sequence '(env proc argl) '(env)
      `(,proc-entry
            (assign env 
                    (op compiled-procedure-env) 
                    (reg proc))
            (assign env
                    (op extend-environment)
                    (const ,formals)
                    (reg argl)
                    (reg env))))
      (compile-sequence (lambda-body exp) 'val 'return))))
    </SCHEME>
    <JAVASCRIPT>
function compile_lambda_body(exp, proc_entry) {
    let formals  = lambda_parameters(exp);
    return append_instruction_sequences(
        make_instruction_sequence(
            list("env", "proc", "argl"),
            list("env"),
            list(proc_entry,
                 assign("env", op("compiled_procedure_env"), reg("proc")),
                 assign("env", op("extend_environment"), constant(formals), reg("argl"), reg("env")))),
        compiled_sequence(lambda_body(exp), "val", "return"));
} 
    </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

    </SUBSECTION>
